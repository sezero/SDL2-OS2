From 788ea2d67266bafdc35a0746ee8abefda639a722 Mon Sep 17 00:00:00 2001
From: Ozkan Sezer <sezeroz@gmail.com>
Date: Mon, 16 Oct 2023 23:10:32 +0300
Subject: [PATCH] tiffcrop.c: remove C99isms added by cve patches

---
 tools/tiffcrop.c |   13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 41efb39..72f6ef4 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -2149,6 +2149,7 @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32
 		/*NOTREACHED*/
       }
     }
+    {
     /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are
      * mutually exclusive) --*/
     char XY, Z, R, S;
@@ -2179,6 +2180,7 @@ overflows.
                   "other PAGE_MODE_x options such as - H, -V, -P, -J or -K is "
                   "not supported and may cause buffer overflows..->exit");
         exit(EXIT_FAILURE);
+     }
     }
   }  /* end process_command_opts */
 
@@ -5241,6 +5243,7 @@ computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,
     max_width = max_length = 0;
     for (i = 0; i < crop->regions; i++)
       {
+      uint32 aux;
       if ((crop->res_unit == RESUNIT_INCH) || (crop->res_unit == RESUNIT_CENTIMETER))
         {
 	x1 = _TIFFClampDoubleToUInt32(crop->corners[i].X1 * scale * xres);
@@ -5260,7 +5263,6 @@ computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,
        *    Therefore, check that and reorder input.
        * (be aware x,y are already casted to (uint32) and avoid (0 - 1) )
        */
-      uint32 aux;
       if (x1 > x2) {
         aux = x1;
         x1 = x2;
@@ -5513,7 +5515,7 @@ static int
 getCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opts *dump)
   {
   struct offset offsets;
-  int    i;
+  int    i,j;
   int32  test;
   uint32 seg, total, need_buff = 0;
   uint32 buffsize;
@@ -5590,7 +5592,7 @@ getCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opt
 
   /* Initialize regions iterator i */
   i = 0;
-  for (int j = 0; j < crop->zones; j++)
+  for (j = 0; j < crop->zones; j++)
     {
     seg = crop->zonelist[j].position;
     total = crop->zonelist[j].total;
@@ -6418,6 +6420,7 @@ static int  correct_orientation(struct image_data *image, unsigned char **work_b
 
   if (image->adjustments & ROTATE_ANY)
     {
+    uint32_t width, length;
     if (image->adjustments & ROTATECW_90)
       rotation = (uint16) 90;
     else
@@ -6436,8 +6439,8 @@ static int  correct_orientation(struct image_data *image, unsigned char **work_b
       /* Dummy variable in order not to switch two times the
        * image->width,->length within rotateImage(),
        * but switch xres, yres there. */
-      uint32_t width = image->width;
-      uint32_t length = image->length;
+      width = image->width;
+      length = image->length;
       if (rotateImage(rotation, image, &width, &length, work_buff_ptr, TRUE))
       {
       TIFFError ("correct_orientation", "Unable to rotate image");
